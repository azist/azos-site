<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Global Distributed System ID Generation (GDID) </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Global Distributed System ID Generation (GDID) ">
    <meta name="generator" content="docfx 2.40.6.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc">
    <meta property="docfx:tocrel" content="../../../toc">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                
                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href="../../documentation-index.html" name="" title="Azos">Azos</a>
                      </li>
                      <li>
                          <a href="../../../out/api/Azos.html" name="" title="API Documentation">API Documentation</a>
                      </li>
                </ul>    </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="global-distributed-system-id-generation-gdid">Global Distributed System ID Generation (GDID)</h1>

<p>IDs are usually generated by database engines. However, this direct approach is not usable in
distributed systems where many database instances can be deployed on physically different hosts.</p>
<p>Pseudo-random IDs like GUID/UUIDs, which are often used as a unique IDs, are not a good solution
for DB keys because GUIDs are not monotonic/homogeneous and consequential database page scattering
which really impedes the performance. IDs are usually used in database indexes -
<strong>sequential IDs are a much better</strong> fit because the BTree index pages are better organized.
For example, PK(primary key) index-organized tables perform  quick lookups of data by PK, but need
to re-organize records on insert if PKs are not consecutive.</p>
<p>Another important benefit of monotonically increasing IDs is the <strong>range partitioning</strong>. It is used
to organize large volumes of data by ranges. This would have been impossible to accomplish with scattered ids.</p>
<p>Azos and Sky libraries provide a solution to aforementioned problems which is suitable for large-scale
distributed systems - generation of <strong>Global Distributed Identifiers</strong> (GDIDs)</p>
<h2 id="gdid-structure-and-properties">GDID Structure and Properties</h2>
<p>GDIDs meet all requirements for IDs in a distributed system:</p>
<ul>
<li><strong>Global Uniqueness</strong> within the system</li>
<li><strong>Monotonically increasing</strong> homogeneous (1,2,3,4,5…) segments</li>
<li><strong>Large resolution</strong> - Named sequences in scopes each having 2^96 resolution</li>
<li>Ability to obtain consecutive <strong>GDIDs in batches</strong> (e.g. request X sequential IDs)</li>
<li><strong>No single point of failure</strong> guaranteed by up to 16 independent ID authorities (see below)</li>
<li><strong>Compact</strong> design - only 12 bytes (era(4) + id(64))</li>
<li>Stored as <strong>byte[12]</strong> - good performance for keys in MongoDB and MySQL (and others)</li>
<li><strong>Compressible</strong> - as the majority of business entity IDs are &quot;small&quot; (less than 1 billion), and due to the structured nature of the GDID, <strong>variable-bit encodings</strong> (i.e. LEB(uint)+LEB(ULONG)) can compress &quot;small&quot; ids to 3-5 bytes (instead of 12)</li>
</ul>
<pre><code class="lang-CSharp">+---------+---------------+-------------------------------------+
|   Era   |   Authority   |               Counter               |
+---------+---------------+-------------------------------------+
   32 bit       4 bit                     60 bit
</code></pre>
<p>To illustrate what a GDID is: 12 bytes = 96 bits
A 96 bit integer can hold:</p>
<pre><code>   2^96 = 79,228,162,514,264,337,593,543,950,336 combinations.
</code></pre>
<p>To illustrate the resolution of this number, suppose that we have, 1,000,000 clients constantly consuming 1,000 GDIDs per second each. This will be enough for 2,500,000,000,000 years of operation (two and a half trillion years of operation).</p>
<p>Another example from the IoT application:</p>
<p>2 ^ 96 / (10B users * 100 devices * 100 msg/sec * 86400 sec/day * 366 d/yr) = 25,000,000 years</p>
<h2 id="gdid-generation">GDID Generation</h2>
<p>GDIDs are generated by specially purposed services - GDID Authorities (agdida service). Authority services are declared in a cluster Metabase root $.acmb file:</p>
<pre><code class="lang-CSharp">  gdid
  {
    authority
    {
      host=&quot;World/US/Center/SH.chi2/SBOX1/app0001&quot;
      network=&quot;internoc&quot;
    }
    // other authorities ...
  }
</code></pre>
<p>There can be up to 16 different authorities in the Sky OS instance, virtually eliminating any single point of failure for GDID generation. GDID authority service implements a contract:</p>
<pre><code class="lang-CSharp">  [Glued]
  [LifeCycle(ServerInstanceMode.Singleton)]
  public interface IGdidAuthority : ISkyService
  {
    GdidBlock AllocateBlock(string scopeName, 
                            string sequenceName, 
                            int blockSize,
                            ulong? vicinity = GDID.COUNTER_MAX);
  }
</code></pre>
<p>where <a href="../Contracts/IGdidAuthority.cs#L33"><code>GdidBlock</code></a> is a unit of allocation.
The <a href="../Contracts/IGdidAuthority.cs"><code>IGdidAuthority</code></a> service is used
in <a href="GdidGenerator.cs"><code>Sky.Identification.GdidGenerator</code></a> - the main class responsible for GDID generation in distributed apps.</p>
<p>GDIDs are generated within logical ‘Scopes’ and ‘Sequences’ and are unique within (scope, sequence) pair. One can think about a scope and a sequence as a database name and a table name inside a database correspondingly.</p>
<p>A consumer of GDIDs obtains them via a <a href="GdidGenerator.cs"><code>GdidGenerator</code></a> instance. SkyOS exposes a global GDID generation service to any app:</p>
<pre><code class="lang-CSharp">  /// &lt;summary&gt; References distributed GDID provider &lt;/summary&gt;
  public static IGdidProvider GdidProvider { get; }
</code></pre>
<p>Used like this:</p>
<pre><code class="lang-CSharp">var gdid = SkySystem.GdidProvider.GenerateOneGdid(&quot;My Namespace&quot;, &quot;Sequence A&quot;);
</code></pre>
<p>The provider will automatically select a <strong>closest authority</strong> to the host which originates the call, and <strong>retry</strong> on the next
closest authority if the first call fails. GdidProvider also caches the ID block and <strong>adjusts the block size</strong> dynamically -
so if the process consumes an ID infrequently the system will allocate a few IDs, if the consumption picks up the IDGenerator
will ask for <strong>larger blocks</strong> - to make less calls. GdidGenerator <strong>replenishes blocks asynchronously</strong> - when the block depletes
below LWM (low water mark) level.</p>
<p>The following illustrates the GDID generation process:</p>
<img src="/doc/img/agdida-01.svg" align="left" width="65%">  
<p><strong>ID leaks are expected</strong>, for example when process asks for IDs, system allocates a block of 10 IDs and then only uses a few,
however this is normal and expected because of the dynamic block sizing it is unlikely that system gets large blocks and does not
use them to the fullest.</p>
<p><br><br><br><br><br><br><br><br><br><br></p>
<p>The methods that obtain new GDIDs by calling the aforementioned functions are more of a low-level
way and should be rarely used, unless you are writing some system code. In business applications developers should
instead generate unique IDs in a declarative fashion via metadata attributes (see <code>UniqueSequence</code>):</p>
<pre><code class="lang-CSharp">  ///&lt;summary&gt; Represents User root record data &lt;summary&gt;
  [Table(targetName: SysConsts.Myi_DS_MYSQL_TARGET, name: &quot;tbl_user&quot;)]
  [UniqueSequence(SysConsts.MDB_AREA_USER, &quot;user&quot;)] //&lt;--- UNIQUE ID Sequence
  public sealed class UserDoc : DataDocWithGdidPKAndInUse
  {
    public UserDoc():base(){}
    ...
  }
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/azist/azos/blob/master/src/Azos.Sky/Identification/readme.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
